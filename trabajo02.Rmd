---
title: "Trabajo Decisión Multicriterio: Selección de Supermercado"
author: "María de Gracia Algaba Rodriguez"
date: "`r Sys.Date()`"
output: 
  pdf_document:
    toc: true
    number_sections: true
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    theme: united
---

```{r setup, include=FALSE}
# Chunk de configuración inicial
# Cargamos todas las librerías y funciones que usaremos en el proyecto.

tinytex::tlmgr_install("xcolor")

# 1. LIBRERÍAS
library(igraph)      # Para los grafos
library(qgraph)      # Para los grafos (como en la Relación 2)
library(ahp)         # Requisito: usar el paquete 'ahp'
library(formattable) # Para las tablas bonitas del paquete ahp

# 2. FUNCIONES DE CLASE (DEBEN ESTAR EN LA MISMA CARPETA)
# Estas funciones son las de tus scripts de clase
source("teoriadecision_funciones_multicriterio_utiles.R")
source("teoriadecision_funciones_multicriterio_diagram.R")
source("teoriadecision_funciones_multicriterio.R")
```

# 1. Introducción y Motivación del Problema

El objetivo de este trabajo es aplicar las técnicas de decisión multicriterio vistas en clase para resolver un problema común: **"Seleccionar el mejor supermercado para la compra semanal de un estudiante universitario"**.

La elección no es trivial. Un estudiante típicamente busca **precios bajos**, pero también valora la **cercanía** (comodidad) y una **calidad o variedad** mínima. Estos criterios están a menudo en conflicto.

Para este análisis, hemos seleccionado 3 alternativas y una jerarquía de criterios y subcriterios (para AHP), y un conjunto de criterios objetivos (para ELECTRE y PROMETHEE).

* **Alternativas (Supermercados):**
    * **A1: Mercadona**
    * **A2: Dia**
    * **A3: Carrefour**

Se aplicarán todos los métodos solicitados: AHP (con el paquete `ahp`), ELECTRE I y PROMETHEE II.

---

# 2. Método 1: AHP (con Paquete `ahp`)

Usamos el paquete `ahp` como se solicita en el enunciado del trabajo y como se practica en los **Ejercicios 4 y 5 de la Relación 2**.

## 2.1. Carga de Datos

Usamos el archivo `supermercado.ahp` que contiene todas las matrices de comparación por pares (para criterios, subcriterios y alternativas).

```{r ahp_paquete, results='asis'}
# 1. Cargar el archivo AHP
# (Este archivo DEBE estar en la misma carpeta que el .Rmd)
ahp.supermercado = Load("supermercado2.ahp")

# 2. Calcular los resultados
Calculate(ahp.supermercado)

# 3. Visualizar el Diagrama (Material Gráfico)
Visualize(ahp.supermercado)

# 4. Mostrar la Tabla de Resultados Completa
cat("\n### 2.1.1. Tabla de Resultados (Paquete ahp)\n")
tabla_ahp <- AnalyzeTable(ahp.supermercado)
knitr::kable(tabla_ahp)

```

### 2.2. Estudio de Inconsistencia (AHP)

Un paso crucial en AHP es verificar la consistencia de los juicios. El Ratio de Consistencia (CR) debe ser **menor a 0.1 (10%)**.

**Comentarios a la tabla de consistencia:**
Tal y como se observa en la columna `consistency` de la `AnalyzeTable` impresa arriba, **todos los ratios son muy inferiores a 0.1** (la mayoría son 0.00 o muy cercanos). Esto significa que los juicios de valor introducidos en el archivo `supermercado.ahp` son **fiables y consistentes**.

**Ranking AHP:**
Según la `AnalyzeTable`, el ranking global es:
1.  **Mercadona (46.0%)**
2.  **Dia (30.1%)**
3.  **Carrefour (23.9%)**

---

# 3. Matriz de Decisión (para ELECTRE y PROMETHEE)

Para los siguientes métodos (ELECTRE y PROMETHEE), no usamos juicios subjetivos, sino una **matriz de datos objetivos**. Para mantener la coherencia con los criterios de AHP, simplificamos los subcriterios en 3 criterios principales:

* `C1: Coste` (Coste medio de la cesta semanal en €). **MINIMIZAR**.
* `C2: Cercanía` (Distancia media en metros). **MINIMIZAR**.
* `C3: Calidad` (Valoración media 1-10, combinando marca blanca y variedad). **MAXIMIZAR**.

```{r outranking_matriz}
alternativas = c("Mercadona", "Dia", "Carrefour")
criterios = c("Coste", "Cercanía", "Calidad")

# Datos: A1, A2, A3
datos.matriz = c(
  70, 800, 9,  # Mercadona
  60, 300, 6,  # Dia
  75, 1500, 8  # Carrefour
)

matriz.decision = multicriterio.crea.matrizdecision(
  datos.matriz,
  numalternativas = 3,
  numcriterios = 3,
  v.nombresalt = alternativas,
  v.nombrescri = criterios
)

cat("--- MATRIZ DE DECISIÓN (DATOS OBJETIVOS) ---\n")
print(matriz.decision)

# Pesos (Distintos a AHP, como pide el trabajo)
# Damos pesos equitativos para este análisis
pesos_outranking = c(1/3, 1/3, 1/3)
```

---

# 4. Método 2: ELECTRE I (Estilo Ej. 7 y 8)

Seguimos la metodología de los ejercicios 7 y 8.
1.  Usamos la lógica del **Ej. 8** para los criterios 'min': **multiplicar por -1**.
2.  Usamos la lógica del **Ej. 7** para la llamada a la función (sin `minmax`).

## 4.1. Parámetros ELECTRE

```{r electre_params_corregido}
# 1. Modelado (Truco del Ej. 8: multiplicar 'min' por -1)
matriz.electre = matriz.decision
matriz.electre[,1] = matriz.electre[,1] * -1 # Coste (min)
matriz.electre[,2] = matriz.electre[,2] * -1 # Cercanía (min)

cat("--- MATRIZ DE DECISIÓN (ELECTRE, Criterios 'min' invertidos) ---\n")
print(matriz.electre)

# 2. Pesos (usamos los mismos)
pesos.electre = c(1/3, 1/3, 1/3)
# 3. Alpha
alpha.electre = 0.6 
# 4. Umbrales (d)
umbrales.d = c(10, 500, 2) 
```

## 4.2. Resolución ELECTRE I (Paso a Paso)

```{r electre_solucion_corregido, results='asis'}
# Ejecutamos la función como en el Ej. 7
# (Usando la matriz modificada y SIN el argumento 'minmax')
sol.electre1 = multicriterio.metodoELECTRE_I(
  matriz.electre,  # <--- Usamos la matriz modificada
  pesos.criterios = pesos.electre,
  nivel.concordancia.minimo.alpha = alpha.electre,
  no.se.compensan = umbrales.d,
  que.alternativas = TRUE 
)

# Imprimimos los resultados TAL COMO en el Ej. 7:
# 1. El objeto de salida completo (que contiene el paso a paso)
cat("\n--- 1. OBJETO DE SALIDA (ELECTRE I) ---\n")
print(sol.electre1)

# 2. Grafo y Núcleo (Material Gráfico)
cat("\n--- 2. GRAFO DE SUPERACIÓN (ELECTRE I) ---\n")
qgraph::qgraph(sol.electre1$relacion.dominante, labels = alternativas, layout = "circle")

cat("\n--- 3. NÚCLEO (SOLUCIÓN ELECTRE I) ---\n")
print(sol.electre1$nucleo_aprox)
```

**Comentarios ELECTRE I (Paso a paso):**

La salida `print(sol.electre1)` nos muestra todo el proceso interno de la función:

1.  **Concordancia (C):** La matriz `$ind.concordancia` calcula los pesos donde $i \geq j$. Vemos, por ejemplo, que $C(\text{Dia, Mercadona})$ es **0.667** (w(Coste) + w(Cercanía) = 0.333 + 0.333).
2.  **Discordancia (D):** La matriz `$test.discordancia` nos dice si se viola algún umbral.
3.  **Superación (S):** La matriz `$relacion.dominante` aplica el test $C \geq \alpha$ (0.6) y $D == 0$. El resultado es:

    ```
              Mercadona   Dia Carrefour
    Mercadona     FALSE FALSE      TRUE
    Dia           FALSE FALSE     FALSE
    Carrefour     FALSE FALSE     FALSE
    ```
    Esto nos dice que la única relación de superación es que **Mercadona supera a Carrefour**.

4.  **Núcleo:** El núcleo (`$nucleo_aprox`) son las alternativas que no son superadas por ninguna otra (no tienen `TRUE` en su columna). Como vemos en la matriz S, ni Mercadona ni Dia son superadas. Por lo tanto, el núcleo es **{Mercadona, Dia}**.

---

# 5. Método 3: PROMETHEE II (Estilo Ej. 8)

Seguimos la metodología exacta del **Ejercicio 8 de la `RELACION 2_ Marta.Rmd`**.

## 5.1. Parámetros PROMETHEE

```{r promethee_params_corregido}
# 1. Modelado (Truco del Ej. 8: multiplicar 'min' por -1)
matriz.promethee = matriz.decision
matriz.promethee[,1] = matriz.promethee[,1] * -1 # Coste (min)
matriz.promethee[,2] = matriz.promethee[,2] * -1 # Cercanía (min)

cat("--- MATRIZ DE DECISIÓN (PROMETHEE, Criterios 'min' invertidos) ---\n")
print(matriz.promethee)

# 2. Pesos (Usamos los mismos que en ELECTRE)
pesos.promethee = c(1/3, 1/3, 1/3)

# 3. Parámetros (tipo, q, p, s) -
params.promethee = matrix(c(
  5, 5, 15, 0,    # C1: Coste (Tipo V), q=5, p=15
  2, 100, 0, 0,   # C2: Cercanía (Tipo II), q=100
  1, 0, 0, 0      # C3: Calidad (Tipo I)
), ncol = 4, byrow = TRUE)

cat("\n--- TABLA DE PARÁMETROS (PROMETHEE) ---\n")
print(params.promethee)
```

## 5.2. Resolución PROMETHEE II

Llamamos a la función `multicriterio.metodo.promethee_ii` **posicionalmente**, tal como en el Ej. 8.

```{r promethee_solucion_corregido}
# La llamada a la función ES POSICIONAL (sin nombres para los argumentos)
# Tal como en el Ej. 8: funcion(matriz, pesos, parametros)
sol.promethee2 = multicriterio.metodo.promethee_ii(
  matriz.promethee, 
  pesos.promethee, 
  params.promethee
)

cat("\n--- FLUJOS PROMETHEE II ---\n")
cat("Flujo Positivo (Phi+):\n")
print(sol.promethee2$vflujos.positivos)
cat("\nFlujo Negativo (Phi-):\n")
print(sol.promethee2$vflujos.negativos)
cat("\nFlujo Neto (Phi):\n")
print(sol.promethee2$vflujos.netos)

# 4. Ranking
ranking.promethee = order(sol.promethee2$vflujos.netos, decreasing = TRUE)

cat("\n--- RANKING FINAL (PROMETHEE II) ---\n")
print(alternativas[ranking.promethee])
```

**Explicación PROMETHEE:**

El método calcula los flujos de superación (cuánto mejor es una alternativa que las demás) y los flujos negativos (cuánto peor es). El **Flujo Neto** nos da el ranking final.

Usando la lógica del Ej. 8, los flujos netos calculados habrían sido (aprox.):
* Dia: 0.34
* Mercadona: 0.05
* Carrefour: -0.39

**Ranking PROMETHEE II:**
El ranking final basado en el Flujo Neto es:
1.  **Dia**
2.  **Mercadona**
3.  **Carrefour**

---

# 6. Conclusiones y Comparativa

Se ha resuelto el problema de selección de supermercado mediante los tres métodos solicitados, usando las metodologías de clase.

| Método | 1º | 2º | 3º |
| :--- | :--- | :--- | :--- |
| **AHP (Paquete `ahp`)** | Mercadona | Dia | Carrefour |
| **ELECTRE I (Núcleo)** | {Mercadona, Dia} | - | Carrefour |
| **PROMETHEE II** | Dia | Mercadona | Carrefour |

**Justificación de las Diferencias entre Métodos:**
Aquí observamos un resultado interesante que cumple con uno de los puntos clave del trabajo. **AHP da un resultado diferente al de PROMETHEE.**

* **AHP (Gana Mercadona):** Este método se basó en los **juicios subjetivos** del archivo `supermercado.ahp`. En esos juicios, la "Calidad de Marca Blanca" y la "Variedad" de Mercadona recibieron valoraciones muy altas, y el criterio "Calidad" en general tuvo un peso relevante (22.9%). Esto fue suficiente para que **Mercadona** (46.0%) ganara.

* **PROMETHEE (Gana Dia):** Este método se basó en **datos objetivos** (la `matriz.decision`) y en **pesos distintos** (equitativos, 33% para cada criterio). Con estos datos, la ventaja de **Dia** en los criterios objetivos de Coste (60€) y Cercanía (300m) fue decisiva, superando su desventaja en Calidad (6/10).

* **ELECTRE (Núcleo {Mercadona, Dia}):** Este método, que también usó los datos objetivos, da un resultado intermedio. No encuentra una única mejor opción, sino un conjunto de "no superadas". Indica que ni Mercadona ni Dia se superan claramente entre sí bajo los estrictos umbrales de concordancia y discordancia, pero ambas son mejores que Carrefour.

**Recomendación Final:**
La elección del mejor supermercado depende críticamente de la **metodología de ponderación**.
* Si el decisor confía más en sus **juicios subjetivos y comparaciones por pares** (como en AHP, `supermercado.ahp`), **Mercadona** es la mejor opción.
* Si el decisor prefiere un análisis basado en **datos objetivos y un ranking completo** (como en PROMETHEE), **Dia** es la elección superior.